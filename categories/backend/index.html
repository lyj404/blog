<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BackEnd | LYJ's Blog</title>
<meta name=keywords content><meta name=description content="This is lyj's blog"><meta name=author content="LYJ"><link rel=canonical href=https://lyj.cloudns.ch/categories/backend/><link crossorigin=anonymous href=/assets/css/stylesheet.6ac597e8fd3ec87b479e9c23e4cdc2c9aed63cb215e157732cbc8732be5732c1.css integrity="sha256-asWX6P0+yHtHnpwj5M3Cya7WPLIV4VdzLLyHMr5XMsE=" rel="preload stylesheet" as=style><link rel=icon href=https://lyj.cloudns.ch/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://lyj.cloudns.ch/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://lyj.cloudns.ch/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://lyj.cloudns.ch/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://lyj.cloudns.ch/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://lyj.cloudns.ch/categories/backend/index.xml><link rel=alternate hreflang=zh-cn href=https://lyj.cloudns.ch/categories/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://lyj.cloudns.ch/categories/backend/"><meta property="og:site_name" content="LYJ's Blog"><meta property="og:title" content="BackEnd"><meta property="og:description" content="This is lyj's blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta property="og:image" content="https://lyj.cloudns.ch/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lyj.cloudns.ch/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="BackEnd"><meta name=twitter:description content="This is lyj's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lyj.cloudns.ch/ accesskey=h title="Home (Alt + H)"><img src=https://lyj.cloudns.ch/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lyj.cloudns.ch/ title="LYJ's Blog"><span>首页</span></a></li><li><a href=https://lyj.cloudns.ch/archives/ title=归档><span>归档</span></a></li><li><a href=https://lyj.cloudns.ch/categories/ title=Categories><span>分类</span></a></li><li><a href=https://lyj.cloudns.ch/tags/ title=Tags><span>标签</span></a></li><li><a href=https://lyj.cloudns.ch/search/ title=搜索><span>搜索</span></a></li><li><a href=https://lyj.cloudns.ch/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://lyj.cloudns.ch/>Home</a>&nbsp;»&nbsp;<a href=https://lyj.cloudns.ch/categories/>Categories</a></div><h1>BackEnd
<a href=/categories/backend/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git提交规范和GitFlow</h2></header><div class=entry-content><p>Git提交规范 在使用git 提交代码的时候，由于每个人都有自己的书写风格，导致git log很混乱，不利于阅读和维护，因此形成了一套通用git提交规范。 格式：
1 type(scope) : subject type是必须项，主要用来描述commit的类别，且只允许使用以下的标示：
feat：新功能（feature） 用于提交新功能 例如：feat: 添加用户注册功能 fix：修复bug 用于提交bug修复 例如：fix：修复登录不成功的问题 docs： 用于提交文档相关的修改 例如：docs：更新README style：代码格式改变 用于提交仅格式化、标点符号、空白等不影响代码运行和逻辑的变更 例如：style：删除多余空格 refactor：代码重构 用于提交某个已有功能重构 例如：refactor：重构用户登录功能 perf：性能优化 用于提交提升程序性能的代码修改 例如：perf： 优化首页加载速度 test：测试相关的操作 用于提交测试相关的内容 例如：test：增加用户登录的单元测试 build：用于描述与项目构建系统相关的更改 用于提交与项目构建系统相关的更改 例如：build：jdk8升级JDK17 revert：撤销上次的commit 用于提交撤销的相关操作 例如：revert：撤销登录逻辑的更改 ci：持续集成相关的配置的更改 用于提交CI相关的修改 例如：ci：修改GitHub Action配置 chore：构建过程或辅助工具的更改 用于提交构建过程、辅助工具等相关内容的修改 例如：chore：fastjson升级fastjson2 scoop是可选项，用于说明commit影响的范围，如：controller层、service层、dao层等等。 subject是必须项，主要是对commit进行简短描述，且不能超过50个字符。
通过工具规范提交 模板文件 创建一个.gitmessage.txt文件，则可自定义git提交模板 例如：
1 2 reason: resolve: 在模板文件定义之后，还需执行以下命令：
1 git config --global commit.template /xx/xx/.gitmessage.txt 使用自定义模板提交方式，不使用git commit -m "xxx"，而是使用git commit，就会自动调用模板
...</p></div><footer class=entry-footer><span title='2025-01-06 20:38:40 +0000 UTC'>2025-01-06</span>&nbsp;·&nbsp;155 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to Git提交规范和GitFlow" href=https://lyj.cloudns.ch/post/git-specifications-gitflow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringBoot使用HTTPS</h2></header><div class=entry-content><p>将SpringBoot项目的HTTP转化成HTTPS只需要在application.yml进行相关的配置，或者是通过实现 WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory> 创建一个配置类，以自动将 HTTP 流量重定向到 HTTPS。这两个方法均可实现将HTTP转为HTTPS。 具体步骤如下：
获取SSL证书 可在阿里云申请免费的SSL证书，也可以使用Java 的 keytool 工具生成自签名证书，由于嫌麻烦所以我使用的是Java 的 keytool 工具生成自签名证书。
1 keytool -genkey -alias myalias -keyalg RSA -keystore keystore.p12 -storetype PKCS12 该命令执行之后，会在命令行提示你输入一些密码以及一些其他信息，如姓名和组织。
方法一 通过配置文件配置HTTPS 在 application.yml或application.properties 文件中，指定密钥库路径、类型、密码和别名： yaml文件写法：
1 2 3 4 5 6 7 server: ssl: key-store: classpath:keystore.p12 key-store-password: your_password key-store-type: PKCS12 key-alias: myalias port: 8443 properties文件写法：
1 2 3 4 5 server.port=8443 server.ssl.key-store=classpath:keystore.p12 server.ssl.key-store-password=your_password server.ssl.key-store-type=PKCS12 server.ssl.key-alias=myalias 方法二 使用WebServerFactoryCustomizer类配置HTTPS 创建一个配置类实现WebServerFactoryCustomizer并重写customize()方法，具体代码如下：
...</p></div><footer class=entry-footer><span title='2024-11-18 20:15:29 +0000 UTC'>2024-11-18</span>&nbsp;·&nbsp;151 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to SpringBoot使用HTTPS" href=https://lyj.cloudns.ch/post/springboot-use-https/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>.gitignore文件的配置使用</h2></header><div class=entry-content><p>在使用Git的过程中，有些文件比如说日志、临时文件、编译的中间文件文件等不需要提交到Git仓库，这个时候需要设置对应的忽略规则，来忽略这些文件的提交。使用场景：比如说在使用git add .命令的时候不小心把不想提交的文件添加到缓存中去了，虽然可以使用git reset HEAD example.txt ，又或者是使用git add 具体文件的方式来避免将不想要提交的文件添加到暂存区，但是这样终归没有直接使用git add .方便，这个时候就可以使用Git为我们提供.gitignore文件，只要在文件中申明哪些文件不需要添加到暂存区，然后在使用git add .命令的时候就不会被添加到暂存区了。
实现在Git中忽略不想提交的文件 直接在项目中定义.gitignore文件，然后在.gitignore文件中定义要忽略的文件 在Git项目的设置中指定忽略文件，在.git/info/exclude文件中写入要忽略的文件 定义Git全局的.gitignore文件，使用命令如下 git config --global core.excludesfile ~/.gitignore .gitignore忽略规则的优先级 由高到低的优先级如下：
从命令行中读取可用的忽略规则 当前目录定义的规则 父级目录定义的规则，依次递推 $GIT_DIR/info/exclude 文件中定义的规则 core.excludesfile中定义的全局规则 .gitignore的匹配语法 空行：空行将被忽略。 以 # 开头的表示为注释。 斜杠 /：如果斜杠出现在行首，表示只匹配项目根目录；如果斜杠出现在其他位置，表示匹配任意位置。 !：感叹号用于取反，即排除某些匹配的文件或目录。 *：星号匹配零个或多个字符。 ?：问号匹配一个字符。 **：双星号匹配任意子目录。 /dir/：表示忽略根目录下的dir目录。 dir/：表示忽略任意位置的dir目录。 /*.txt：表示只匹配根目录下的.txt文件。 debug.log：表示忽略任意位置的debug.log文件。 **/logs/：表示匹配所有子目录中的logs目录。 *.log：表示匹配所有以.log结尾的文件。 assets/：表示匹配名为assets的目录。 build：表示匹配名为build的文件或目录。 build/：表示只匹配名为build的目录。 gitignore该开源项目收集了所有可用的.gitignore模板
Java .gitignore template
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Compiled class file *.class # Log file *.log # BlueJ files *.ctxt # Mobile Tools for Java (J2ME) .mtj.tmp/ # Package Files # *.jar *.war *.nar *.ear *.zip *.tar.gz *.rar # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml hs_err_pid* replay_pid* .gitignore配置不生效原因和解决 在Git中，即使在.gitignore中标明了要忽略的文件或目录，但如果这些文件已经被纳入版本管理，依然会出现在git push的目录中，并且在使用git status查看状态时仍然显示为被追踪的文件。这是因为Git会缓存已经纳入版本管理的文件，即使在.gitignore中声明了忽略路径也不会生效。
...</p></div><footer class=entry-footer><span title='2024-03-02 17:16:07 +0000 UTC'>2024-03-02</span>&nbsp;·&nbsp;152 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to .gitignore文件的配置使用" href=https://lyj.cloudns.ch/post/gitignore-file-use/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MongoDB的基本操作</h2></header><div class=entry-content><p>MongoDB简介 MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供一个可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB官网地址： MongoDB官网
MongoDB概念 SQL术语 MongoDB术语 说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接，MongoDB不支持表连接 primary key primary key 主键/MongoDB自动将_id字段设置为主键 数据库 MongoDB中可以建立多个数据库，默认的数据库为db ，该数据库存储在data目录中，每一个数据库都有自己集合和权限，不同的数据库放置在不同的文件中。
1 2 3 4 5 6 7 8 9 10 # 显示MongoDB服务器上的所有数据库 show dbs # 示例输出 # admin 0.000GB # local 0.000GB # test 0.001GB # 显示当前所使用的数据库 db # 指定使用某个数据库 use local MongoDB默认自带三个数据库：admin、local、config
...</p></div><footer class=entry-footer><span title='2024-01-09 19:39:59 +0000 UTC'>2024-01-09</span>&nbsp;·&nbsp;1464 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to MongoDB的基本操作" href=https://lyj.cloudns.ch/post/mongodb-description/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DDD领域驱动设计</h2></header><div class=entry-content><p>Domain Driver Design MVC架构 在mvc架构中，主要划分为三个组件：Model（模型）、View（视图）、Controller（控制器） 传统三层架构模型(MVC) DDD架构 DDD架构主要将应用分成四个层次：
表现层（Presentation Layer）：负责与用户进行交互，展示数据和接收用户输入。表现层通常包括用户界面、控制器、视图和用户输入验证等组件。 应用层（Application Layer）：负责协调处理用户请求，并将其转化为对领域层的操作。应用层中的服务和命令处理程序执行应用程序逻辑，调用领域层中的领域对象来完成具体的业务处理。应用层还负责事务管理和协调不同领域对象之间的交互。 领域层（Domain Layer）：是整个架构的核心，包含了业务领域的核心概念、业务规则和业务逻辑。领域层由聚合、实体、值对象等领域对象组成，它们封装了业务行为和状态，并通过领域服务之间的交互来完成复杂的业务操作。 基础设施层（Infrastructure Layer）：提供支持上述三个层次的基础设施和技术实现，如数据库访问、消息队列、外部服务和框架等。基础设施层隐藏了底层技术的细节，提供统一的接口供上层调用。 DDD架构模型 COLA COLA架构 Adapter层：负责对前端展示的路由和适配，对应传统的B/S架构来说，adapter相当于之前的controller App层：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层 Domain层：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次； Infrastructure层：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。 Client层：对外提供的功能API，如果外部模块需要使用本项目功能只需引用 client 中的 API 接口即可实现功能、
adapter web 处理页面请求的Controller app 业务功能包（user、order）放xxxServiceImpl 业务名 app executor 修改相关的执行逻辑 app query(executor包下) 查询相关的执行逻辑 client api(放xxxService) 存放对外功能的api client dto（data、query） 对外返回的对象及调用方传入的参数对象 domain gateway 防腐层，让 Infrastructure 层实现逻辑 domain 业务功能包（entity、值对象） 根据业务功能分包，包中存放业务实体及值对象 infrastructure convertor 存放将 DO 转化为 entity的类 infrastructure config 存放配置相关 infrastructure gateway.impl 实现 domain 层的 gateway 接口的实现类 infrastructure dataobject 存放数据库对象的DO infrastructure mapper mapper文件 ...</p></div><footer class=entry-footer><span title='2023-10-08 16:29:12 +0000 UTC'>2023-10-08</span>&nbsp;·&nbsp;78 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to DDD领域驱动设计" href=https://lyj.cloudns.ch/post/domain-driver-design-desciption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringBoot自动装配原理</h2></header><div class=entry-content><p>SPI SpringBoot的自动装配是通过SPI的方式实现的，并进行了进一步的优化，从而实现了自动装配。SPI全称为Serveice Provider Interface，是Java提供的一种服务发现机制。它允许不同的组件在运行时动态的扩展、替换和加载实现。SPI是一种基于接口和实现分离的设计模式。 在SPI机制中，定义一个接口作为服务的标准化接口，然后通过类路径下提供特定配置文件来指定具体的实现。这个配置文件通常位于META-INF/services目录下，以接口的全限定名命名。配置文件中列出了实现该接口的具体类的全限定名。 当需要使用某项服务时，应用程序可以通过SPI机制查找平加载对应的实现类。Java运行时会通过读取配置文件获取到实现类的信息，并实例化对应的类。这样能够做到在不修改代码的情况下，通过添加/替换配置文件中的实现类，来改变程序的行为或者增加新功能。
SPI的应用 JDBC数据库驱动 日志框架（SLF4） SpringBoot自动装配原理 SpringBoot自动配置是默认开启的，spring.boot.enableautoconfiguration=true，可以通过application.properties或application.yml来关闭自动配置。 SpringBoot应用都会创建一个启动类，启动类上包含了@SpringBootApplication注解，这个注解是一个复合的注解，分别对这三个注解进行了封装@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan。
1 2 3 4 5 6 7 8 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } @SpringBootApplication注解的实现
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @SpringBootConfiguration：用于标识一个类是SpringBoot的配置类。 @EnableAutoConfiguration：启动SpringBoot的自动配置机制。 @ComponentScan：扫描被@Component注解的Bean，注解默认会扫描启动类所在的包下的所有类。
...</p></div><footer class=entry-footer><span title='2023-09-26 21:42:12 +0000 UTC'>2023-09-26</span>&nbsp;·&nbsp;166 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to SpringBoot自动装配原理" href=https://lyj.cloudns.ch/post/springboot-autoconfiguration-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>sychronized底层实现</h2></header><div class=entry-content><p>sychronized sychronized是Java的关键字，用于实现线程之间的同步，保证多个线程对共享资源的安全访问，也被成为同步锁。 sychronized的作用是保证在同一时刻，被修饰的代码块或者方法只会有一个线程执行，以达到保证并发安全的效果。
sychronized的使用方式 sychronized主要有三种使用方式：
修饰实例方法：对于当前实例加锁 1 2 public sychronized void methodName(){ } 修饰静态方法：对于当前类对象加锁 1 public static sychronized void methodName(){} 修饰代码块：对给定的对象加锁 1 sychronized(this){} sychronized的底层实现 sychronized的底层实现依赖于JVM，因此sychronized的与JVM内存的存储：Java对象头、以及monitor对象监视器有关。
Java对象头 在JVM中，对象在内存中的存储布局，分为三个部分：
对象头 实例数据 对齐填充 在Java中，每个对象都有一个对象头（Object Header），它包含了一些用于管理对象的元数据信息。 对象头的具体结构和内容取决于JVM的实现和配置，并且可能会因为不同版本的JVM和不同的操作系统而有所区别。一些常见的对象头结构和字段如下：
Mark Word（标记字段）：占用对象头的一部分，用于存储对象的标记状态和锁信息。sychronized使用的锁对象是存储在Java的对象头的标记字段里。标记字段通常包含了以下信息 对象的哈希码（用于支持hashCode()方法） 锁状态（是否被锁定、偏向锁或轻量级锁的标识等） 并发标记（用于支持垃圾回收、对象分代等） 偏向锁的线程ID 偏向时间戳 类型指针：指向对象的类元数据的指针，用于确定对象属于哪个类。 数组长度：如果对象是数组类型，则会包含数字的长度信息。 除常见字段外，对象头可能还包含其他与垃圾回收、锁机制和JIT编译等相关的信息。并且对象头的大小是固定的，在不同JVM上可能有所不同。例如：在32位JVM上对象头通常占8个字节，而在64位JVM上通常占12或16个字节。
Monitor 通过javap -c -s -v -l SynchronizedDemo.class命令反编译代码，可以看到相对应的字节码指令。 sychronized在修饰代码块的时候，JVM采用monitorenter和monitorexit两个指令来实现同步，monitorenter指令指向同步代码块开始的位置，monitorexit指令指向同步代码块结束的位置。 sychronized在修饰实例方法的时候，JVM采用ACC_SYNCHRONIZED标识符来实现同步，通过这个标识来指明这是一个同步方法 上述的三个命令都是基于Monitor实现的。
实例对象结构中有对象头，对象头中有一个结构Mark Word，Mark Word的指针指向了Monitor。 Monitor是一种同步机制，在JVM中，Monitor的实现是由ObjectMonitor实现的，称之为Monitor锁。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ObjectMonitor() { _header = NULL; _count = 0; // 由于synchronized是可重入锁，count用于记录当前对象锁拥有者线程获取锁的次数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; // 调用了wait方法，处于WAIT/TIME_WAIT的线程，会被加入到WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; // 处于等待锁block状态的线程，会被加入到EntryList _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } 对象监视器主要基于ObjectMonitor结构体中的EntryList、WaitSet两个队列以及计数器count实现的。
...</p></div><footer class=entry-footer><span title='2023-09-20 16:14:47 +0000 UTC'>2023-09-20</span>&nbsp;·&nbsp;166 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to sychronized底层实现" href=https://lyj.cloudns.ch/post/sychronized-underlying-implementation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>实现HashMap(JDK1.7)</h2></header><div class=entry-content><p>哈希表 HashMap是数据结构中的哈希表在Java中的具体实现。 哈希表(Hash Table)是一种常见的数据结构，也被称为散列表。它通过将键映射到存储桶(Buckets)中的位置来高效的存储和检索数据。哈希表使用一个哈希函数来计算键的散列值，然后将散列值映射到存储桶的索引上。 哈希表由存储桶数组和哈希函数组成。
存储桶数组 存储桶数组(Bucket Array)是哈希表中用于存储数据的主要结构，它是由一个固定数量的存储桶(Bucket)组成的数组。每个存储桶可以存储一个或多个元素，每个元素都由一个键值对(key-value pair)组成，其中键用于计算哈希值，而值代表实际存储的数据。
哈希函数 哈希函数(Hash Function)是一种算法，它可以将任意长度的输入数据映射成固定长度输出，这个输出通常称为哈希值。
哈希函数构造 哈希函数的构造是哈希表实现的关键之一。常见的哈希函数构造方法：
直接定值法：直接通过键值映射到对应的数组位置。 数字分析法：取键的某些数字作为映射的位置。 平方取中法：取键平放的中间几位作为映射的位置。 折叠法：将键分割成数位相同的几段，然后把它们的叠加和作为映射的位置。 随机数法：使用一个随机数发生器生成一个随机数作为哈希值。 除留余数法：键除以一个足够大的质数，所得的余数作为哈希地址。 哈希冲突 哈希冲突(Hash Collision)是指两个或多个不同的元素被哈希函数映射到相同的哈希值。哈希表设计的目标是将元素均匀的分布在不同的槽位上，以避免冲突和提高效率。然而，由于哈希函数的限制和输入数据的多样性，冲突是难以避免的。
解决方法 哈希冲突(Hash Collision)解决方法：
开发地址发：当发生冲突的时候，通过线性探测、二次探测、双重哈希等方法，在哈希表中寻找到下一个可用的位置。 链地址法：当发生冲突的时候，在哈希表的每一个槽位上维护一个链表，将冲突的元素存储在同一个槽位上。 再哈希法：构造多个哈希函数，在发生冲突时，更换哈希函数，直到找到空闲位置。 实现HashMap 整体设计方案：
哈希函数：采用hashCode()加上除留余数法 哈希冲突解决方法：链地址法 定义成员变量 定义MyHashMap的成员变量：
定义默认容量 定义默认负载因子 定义MyHashMap的大小 定义桶数组 自定义内部节点类来实现桶数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //自定义内部节点类 class Node&lt;K, V>{ /** * 键 */ private K key; /** * 值 */ private V value; /** * 后继 */ private Node&lt;K, V> next; public Node(K key, V value) { this.key = key; this.value = value; } public Node(K key, V value, Node&lt;K, V> next) { this.key = key; this.value = value; this.next = next; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 16; /** * 默认负载因子 */ private static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * MyHashMap的大小 */ private int size; /** * 桶数组 */ private Node&lt;K, V>[] buckets; 初始化 定义两个构造函数，一个为无参构造函数，并为桶设置默认容量；另一个为有参构造函数，通过参数指定桶的容量。
...</p></div><footer class=entry-footer><span title='2023-09-18 20:18:43 +0000 UTC'>2023-09-18</span>&nbsp;·&nbsp;1395 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to 实现HashMap(JDK1.7)" href=https://lyj.cloudns.ch/post/java1.7-hashmap-implement/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring循环依赖</h2></header><div class=entry-content><p>循环依赖 循环依赖是指两个或多个模块或组件之间相互依赖，形成一个闭环情况。
1 2 3 4 5 6 7 8 9 10 @Component public class A { @Autowired private B b; } @Component public class B { @Autowired private A a; } Spring解决循环依赖的限制条件 出现循环依赖的Bean必须是单例Bean，原型Bean不可以 原型Bean每次获取的时候都会创建一个新的Bean，假设A、B循环依赖了，A里面要注入B，B里面要注入A，注入一次就会产生一个新的Bean，最终会无穷无尽。 不全是使用构造器注入的 均采用setter方法注入的，可以被Spring解决 均采用构造器方式注入的，不可以被Spring解决 setter和构造器两种方式都使用，需要具体分析 使用构造器注入时，当A依赖B，而B又依赖A，Spring会尝试先创建A。但是，在创建A时，由于它依赖的B还没有创建完成，无法传递给构造器进行注入，从而导致循环依赖无法被解决。
三级缓存 Spring通过三级缓存来解决循环依赖问题。
单例对象缓存(singletonObjects)：存放完整的Bean对象，包括所有属性都已经注入完成的Bean。 早期对象缓存(earlySingletonObjects)：存放半成品对象，即Bean的实例化和依赖注入已经完成，但是初始化还未执行完成的Bean。 单例工厂缓存(singletonFactories)：存放用于创建完整Bean对象的Factory对象。 Spring 解决循环依赖的过程 Spring容器启动之后，开始创建Bean。 容器根据配置信息实例化完成A，但是还没有初始化，紧接着A与一个ObjectFactory对象放入三级缓存。如果A被AOP代理，通过这个工厂获取到的就是A代理后的对象，如果没有代理，工厂最后获取到的就是A的实例化对象 初始化A，为A属性赋值，发现要依赖注入B，于是将B实例化，在B还未初始化的时候将B和一个ObjectFactory对象放入三级缓存 初始化B，发现需要依赖注入A，此时在三级缓存中找到了A与ObjectFactory&lt;?> singletonFactory，通过singletonFactory.getObject()，得到A的引用，并将其存入二级缓存，且从三级缓存移除。 B从二级缓存中获取到不完整的A，并注入到B中，B初始化完成，并将B在二级缓存、三级缓存中的引用清除，同时将实例化完成的B存入一级缓存 B实例化完成后，继续A的初始化，A从一级缓存中获取到B，同样，并将A二级缓存、三级缓存中的引用清除，同时将实例化完成的A存入一级缓存 A和B实例完成，并且二级缓存和三级缓存中都没有A和B了 为什么要三级缓存？二级为什么不可以？ 三级缓存中存放的是生成具体对象的匿名内部类，在获取对象的时候，既可以生成代理对象，又可以生成普通的对象，使用三级缓存可以保证不管什么时候使用的都是一个对象。
...</p></div><footer class=entry-footer><span title='2023-09-07 18:01:30 +0000 UTC'>2023-09-07</span>&nbsp;·&nbsp;58 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to Spring循环依赖" href=https://lyj.cloudns.ch/post/spring-circular-dependency/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring Bean的生命周期</h2></header><div class=entry-content><p>Bean的生命周期 在Java应用中，普通的Java Bean的生命周期很简单。使用关键字new对Bean进行实例化，之后Bean就可使用了，当Bean不在被使用就会被Java的垃圾回收机制回收。概括的说就是两个阶段：
实例化 不使用之后垃圾回收 Spring的Bean的生命周期则比较复杂，Spring的Bean由IOC容器进行实例化、组装和管理。IOC(Inversion of Control，控制反转)是一种软件设计原则，用于实现松耦合和可维护的代码结构。
Spring Bean的生命周期主要分为四个部分
实例化(Instantiation) 属性赋值(Populate) 初始化(Initialization) 销毁(Destruction) Spring Bean详细生命周期： 在Spring框架中，Bean的生命周期经历了以下几个阶段：
实例化(Instantiation)：Spring容器根据配置信息或注解创建Bean的实例。 属性赋值(Populate)：Spring容器将属性值和依赖注入到Bean中。 设置Bean名称：如果Bean实现了BeanNameAware接口，将会调用setBeanName()方法，把Bean的名称传递给它。 设置BeanFactory的引用：如果Bean实现了BeanFactoryAware接口，将会调用setBeanFactory()方法，把Bean所在的BeanFactory传递给它。 设置其他自定义上下文：如果Bean实现了ApplicationContextAware接口，将会调用setApplicationContext()方法，把ApplicationContext传递给它。 Bean后处理(BeanPostProcessor)：Spring容器会对所有的BeanPostProcessor进行初始化，这些后处理可以对Bean实例化前后进行一些自定义操作。 初始化(Initialization)：如果Bean实现了InitializingBean接口，将会调用afterPropertiesSet()方法来执行自定义初始化逻辑。另外，还可以通过配置文件使用init-method属性制定Bean的初始化方法。 自定义初始化(Custom Initialization)：在Bean初始化之后，可以执行一些自定义的初始化逻辑。 销毁(Destruction)：如果Bean实现了DisposableBean接口，将会调用destroy()方法来执行自定义销毁逻辑。同样，还可以通过配置文件使用destory-method属性制定Bean的初始化方法。 自定义销毁(Custom Destruction)：在 Bean 销毁之前，可以执行一些自定义的销毁逻辑。 Bean的生命周期可以通过配置方式进行管理，例如使用XML配置或者是注解。同时，Spring还提供了各种扩展点和回调接口，使开发者能够在Bean的生命周期的不同阶段进行定制化操作。
扩展点 Spring如果监测到Bean实现了Aware接口，则会为其注入相应的依赖。因此通过让Bean实现Aware接口，能够让Bean获得相应的Spring容器资源 Aware接口：
BeanNameAware：注入当前Bean对应的名称 BeanClassLoaderAware：注入加载当前Bean的ClassLoader BeanFactoryAware：注入当前BeanFactory的引用 BeanPostProcessor BeanPostProcessor是Spring的一个重要的接口，用于在Bean初始化前后进行扩展和自定义处理。它是Bean生命周期的一部分，主要用于在容器实例化Bean和将其添加到应用程序上下文之后，以及Bean初始化前后对Bean的定制化操作。
1 2 3 4 5 6 7 8 9 public interface BeanPostProcessor { default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; } } postProcessBeforeInitialization(Object bean, String beanName)：Bean初始化之前调用该方法。接收两个参数：正在初始化的Bean的对象和Bean的名称。可以对此方法中的Bean进行修改和增强。如果返回的对象不为null，则该对象作为最终的Bean实例。 postProcessAfterInitialization(Object bean, String beanName)：在Bean初始化之后调用该方法。接收两个参数：已经完成初始化的Bean对象和Bean的名称。可以对此方法中的Bean进行修改和增强。如果返回的对象不为null，则该对象作为最终的Bean实例。 通过实现BeanPostProcessor接口，在Spring容器实例化Bean和初始化Bean的过程中介入，可以实现一些功能：
...</p></div><footer class=entry-footer><span title='2023-09-07 16:06:24 +0000 UTC'>2023-09-07</span>&nbsp;·&nbsp;92 字数&nbsp;·&nbsp;LYJ</footer><a class=entry-link aria-label="post link to Spring Bean的生命周期" href=https://lyj.cloudns.ch/post/spring-bean-lifecycle/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://lyj.cloudns.ch/categories/backend/page/2/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://lyj.cloudns.ch/>LYJ's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>