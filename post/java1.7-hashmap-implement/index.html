<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>实现HashMap(JDK1.7) | LYJ's Blog</title>
<meta name=keywords content="HashMap,实现HashMap,Java"><meta name=description content="HashMap是数据结构中的哈希表在Java中的具体实现。JDK1.7的HashMap采用数组+链表的方式实现。"><meta name=author content="LYJ"><link rel=canonical href=https://lyj.cloudns.ch/post/java1.7-hashmap-implement/><link crossorigin=anonymous href=/assets/css/stylesheet.625b655134c8fb20526ea156a9e21bf567138d148c9a030df52c0ec366106466.css integrity="sha256-YltlUTTI+yBSbqFWqeIb9WcTjRSMmgMN9SwOw2YQZGY=" rel="preload stylesheet" as=style><link rel=icon href=https://lyj.cloudns.ch/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lyj.cloudns.ch/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://lyj.cloudns.ch/favicon.png><link rel=apple-touch-icon href=https://lyj.cloudns.ch/favicon.png><link rel=mask-icon href=https://lyj.cloudns.ch/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lyj.cloudns.ch/post/java1.7-hashmap-implement/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://lyj.cloudns.ch/post/java1.7-hashmap-implement/"><meta property="og:site_name" content="LYJ's Blog"><meta property="og:title" content="实现HashMap(JDK1.7)"><meta property="og:description" content="HashMap是数据结构中的哈希表在Java中的具体实现。JDK1.7的HashMap采用数组+链表的方式实现。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-09-18T20:18:43+00:00"><meta property="article:modified_time" content="2023-09-18T20:18:43+00:00"><meta property="article:tag" content="HashMap"><meta property="og:image" content="https://lyj.cloudns.ch/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lyj.cloudns.ch/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="实现HashMap(JDK1.7)"><meta name=twitter:description content="HashMap是数据结构中的哈希表在Java中的具体实现。JDK1.7的HashMap采用数组+链表的方式实现。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lyj.cloudns.ch/post/"},{"@type":"ListItem","position":2,"name":"实现HashMap(JDK1.7)","item":"https://lyj.cloudns.ch/post/java1.7-hashmap-implement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"实现HashMap(JDK1.7)","name":"实现HashMap(JDK1.7)","description":"HashMap是数据结构中的哈希表在Java中的具体实现。JDK1.7的HashMap采用数组+链表的方式实现。","keywords":["HashMap","实现HashMap","Java"],"articleBody":"哈希表 HashMap是数据结构中的哈希表在Java中的具体实现。 哈希表(Hash Table)是一种常见的数据结构，也被称为散列表。它通过将键映射到存储桶(Buckets)中的位置来高效的存储和检索数据。哈希表使用一个哈希函数来计算键的散列值，然后将散列值映射到存储桶的索引上。 哈希表由存储桶数组和哈希函数组成。\n存储桶数组 存储桶数组(Bucket Array)是哈希表中用于存储数据的主要结构，它是由一个固定数量的存储桶(Bucket)组成的数组。每个存储桶可以存储一个或多个元素，每个元素都由一个键值对(key-value pair)组成，其中键用于计算哈希值，而值代表实际存储的数据。\n哈希函数 哈希函数(Hash Function)是一种算法，它可以将任意长度的输入数据映射成固定长度输出，这个输出通常称为哈希值。\n哈希函数构造 哈希函数的构造是哈希表实现的关键之一。常见的哈希函数构造方法：\n直接定值法：直接通过键值映射到对应的数组位置。 数字分析法：取键的某些数字作为映射的位置。 平方取中法：取键平放的中间几位作为映射的位置。 折叠法：将键分割成数位相同的几段，然后把它们的叠加和作为映射的位置。 随机数法：使用一个随机数发生器生成一个随机数作为哈希值。 除留余数法：键除以一个足够大的质数，所得的余数作为哈希地址。 哈希冲突 哈希冲突(Hash Collision)是指两个或多个不同的元素被哈希函数映射到相同的哈希值。哈希表设计的目标是将元素均匀的分布在不同的槽位上，以避免冲突和提高效率。然而，由于哈希函数的限制和输入数据的多样性，冲突是难以避免的。\n解决方法 哈希冲突(Hash Collision)解决方法：\n开放地址法：当发生冲突的时候，通过线性探测、二次探测、双重哈希等方法，在哈希表中寻找到下一个可用的位置。 链地址法：当发生冲突的时候，在哈希表的每一个槽位上维护一个链表，将冲突的元素存储在同一个槽位上。 再哈希法：构造多个哈希函数，在发生冲突时，更换哈希函数，直到找到空闲位置。 实现HashMap 整体设计方案：\n哈希函数：采用hashCode()加上除留余数法 哈希冲突解决方法：链地址法 定义成员变量 定义MyHashMap的成员变量：\n定义默认容量 定义默认负载因子 定义MyHashMap的大小 定义桶数组 自定义内部节点类来实现桶数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //自定义内部节点类 class Node\u003cK, V\u003e{ /** * 键 */ private K key; /** * 值 */ private V value; /** * 后继 */ private Node\u003cK, V\u003e next; public Node(K key, V value) { this.key = key; this.value = value; } public Node(K key, V value, Node\u003cK, V\u003e next) { this.key = key; this.value = value; this.next = next; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 16; /** * 默认负载因子 */ private static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * MyHashMap的大小 */ private int size; /** * 桶数组 */ private Node\u003cK, V\u003e[] buckets; 初始化 定义两个构造函数，一个为无参构造函数，并为桶设置默认容量；另一个为有参构造函数，通过参数指定桶的容量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 无参构造方法，设置桶数组大小为默认容量 */ public MyHashMap(){ this.buckets = new Node[DEFAULT_CAPACITY]; this.size = 0; } /** * 有参构造器，设置桶的容量 * @param capacity int */ public MyHashMap(int capacity){ buckets = new Node[capacity]; this.size = 0; } 哈希函数 通过hashCode()和除留余数法实现哈希函数，来获取哈希地址。\n1 2 3 4 5 6 7 8 /** * 哈希函数，获取哈希地址 * @param key K * @return int */ private int hash(K key, int length){ return Math.abs(key.hashCode() \u0026 (length - 1)); } 添加元素 添加元素逻辑：\n判断是否需要扩容 获取元素插入位置 如果要插入的位置为空，则插入元素 如果不为空，则遍历链表 如果元素的key和节点的相同，则覆盖，否则新建节点插入链表头部(JDK7的HashMap使用头插法) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 添加方法 * @param key K * @param value V */public void put(K key, V value){ if (size \u003e= buckets.length * DEFAULT_LOAD_FACTOR) { resize(); } putVal(key, value, buckets); } /** * 将元素存入Node数组 * @param key K * @param value V * @param table Node */private void putVal(K key, V value, Node\u003cK,V\u003e[] table) { //获取插入位置 int index = hash(key); Node\u003cK, V\u003e node = table[index]; //如果要插入的位置为空，则插入元素 if (node == null) { table[index] = new Node\u003c\u003e(key, value); size++; return; } //如果不为空，说明发生了哈希冲突，遍历链表使用链地址法 while (node != null){ //如果元素的key和节点的相同，则覆盖 if ((node.key.hashCode() == key.hashCode()) \u0026\u0026 (node.key == key || node.key.equals(key))){ node.value = value; return; } node = node.next; } //新建节点插入链表头部 Node\u003cK, V\u003e kvNode = new Node\u003c\u003e(key, value, table[index]); table[index] = kvNode; size++; } 扩容 扩容逻辑：\n创建两倍容量的新数组 将当前桶中的元素重新哈希到新的数组 重新MyHashMap设置大小 将旧的桶数组的元素移到新的桶数组中 将扩容后的数组赋值给原来的桶数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 重新哈希元素 * @param newNode Node[] */private void rehash(Node\u003cK,V\u003e[] newNode) { //重新MyHashMap设置大小 this.size = 0; //将旧的桶数组的元素移到新的桶数组中 for (int i = 0; i \u003c buckets.length; i++){ if (buckets[i] == null){ continue; } Node\u003cK, V\u003e node = buckets[i]; while (node != null){ //将元素放入新的桶数组 putVal(node.key, node.value, newNode); node = node.next; } } } 获取元素 获取元素逻辑：\n通过哈希获取地址 如果链表存在遍历链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 获取元素 * @param key K * @return V */public V get(K key){ //获取地址 int index = hash(key, buckets.length); if (buckets[index] == null) { return null; } Node\u003cK, V\u003e node = buckets[index]; while (node != null){ if ((node.key.hashCode() == key.hashCode()) \u0026\u0026 (node.key == key || node.key.equals(key))){ return node.value; } //如果链表存在遍历链表 if (node.next != null){ node = node.next; } } return null; } 删除元素 删除元素逻辑：\n如果key存在则删除，不存在直接返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 移除元素 * @param key K */public void remove(K key){ //获取地址 int index = hash(key, buckets.length); if (buckets[index] == null) { return; } if (buckets[index].key.equals(key)) { buckets[index] = buckets[index].next; return; // 移除成功，结束操作 } Node\u003cK, V\u003e node = buckets[index]; while (node.next != null) { if (node.next.key.equals(key)) { node.next = node.next.next; return; // 移除成功，结束操作 } node = node.next; // 继续遍历链表下一个节点 } } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 public class MyHashMap\u003cK, V\u003e { class Node\u003cK, V\u003e{ /** * 键 */ private K key; /** * 值 */ private V value; /** * 后继 */ private Node\u003cK, V\u003e next; public Node(K key, V value) { this.key = key; this.value = value; } public Node(K key, V value, Node\u003cK, V\u003e next) { this.key = key; this.value = value; this.next = next; } } /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 16; /** * 默认负载因子 */ private static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * MyHashMap的大小 */ private int size; /** * 桶数组 */ private Node\u003cK, V\u003e[] buckets; /** * 无参构造方法，设置桶数组大小为默认容量 */ public MyHashMap(){ this.buckets = new Node[DEFAULT_CAPACITY]; this.size = 0; } /** * 有参构造器，设置桶的容量 * @param capacity int */ public MyHashMap(int capacity){ buckets = new Node[capacity]; this.size = 0; } /** * 哈希函数，获取哈希地址 * @param key K * @return int */ private int hash(K key, int length){ return Math.abs(key.hashCode() \u0026 (length - 1)); } /** * 添加方法 * @param key K * @param value V */ public void put(K key, V value){ if (size \u003e= buckets.length * DEFAULT_LOAD_FACTOR) { resize(); } putVal(key, value, buckets); } /** * 将元素存入Node数组 * @param key K * @param value V * @param table Node */ private void putVal(K key, V value, Node\u003cK,V\u003e[] table) { //获取插入位置 int index = hash(key, table.length); Node\u003cK, V\u003e node = table[index]; //如果要插入的位置为空，则插入元素 if (node == null) { table[index] = new Node\u003c\u003e(key, value); size++; return; } //如果不为空，说明发生了哈希冲突，遍历链表使用链地址法 while (node != null){ //如果元素的key和节点的相同，则覆盖 if ((node.key.hashCode() == key.hashCode()) \u0026\u0026 (node.key == key || node.key.equals(key))){ node.value = value; return; } node = node.next; } //新建节点插入链表头部 Node\u003cK, V\u003e kvNode = new Node\u003c\u003e(key, value, table[index]); table[index] = kvNode; size++; } /** * 扩容 */ private void resize() { //创建两倍容量的新数组 Node\u003cK, V\u003e[] newNode = new Node[buckets.length * 2]; rehash(newNode); buckets = newNode; } /** * 重新哈希元素 * @param newNode Node[] */ private void rehash(Node\u003cK,V\u003e[] newNode) { //重新MyHashMap设置大小 this.size = 0; //将旧的桶数组的元素移到新的桶数组中 for (int i = 0; i \u003c buckets.length; i++){ if (buckets[i] == null){ continue; } Node\u003cK, V\u003e node = buckets[i]; while (node != null){ //将元素放入新的桶数组 putVal(node.key, node.value, newNode); node = node.next; } } } /** * 获取元素 * @param key K * @return V */ public V get(K key){ //获取地址 int index = hash(key, buckets.length); if (buckets[index] == null) { return null; } Node\u003cK, V\u003e node = buckets[index]; while (node != null){ if ((node.key.hashCode() == key.hashCode()) \u0026\u0026 (node.key == key || node.key.equals(key))){ return node.value; } //如果链表存在遍历链表 if (node.next != null){ node = node.next; } } return null; } /** * 移除元素 * @param key K */ public void remove(K key){ //获取地址 int index = hash(key, buckets.length); if (buckets[index] == null) { return; } if (buckets[index].key.equals(key)) { buckets[index] = buckets[index].next; return; // 移除成功，结束操作 } Node\u003cK, V\u003e node = buckets[index]; while (node.next != null) { if (node.next.key.equals(key)) { node.next = node.next.next; return; // 移除成功，结束操作 } node = node.next; // 继续遍历链表下一个节点 } } /** * 返回MyHashMap大小 * @return int */ public int size(){ return this.size; } } 测试 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { MyHashMap\u003cString, String\u003e map = new MyHashMap\u003c\u003e(); map.put(\"test\", \"lyj is test\"); map.remove(\"test\"); System.out.println(map.get(\"test\")); } } ","wordCount":"3173","inLanguage":"zh","image":"https://lyj.cloudns.ch/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-09-18T20:18:43Z","dateModified":"2023-09-18T20:18:43Z","author":{"@type":"Person","name":"LYJ"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lyj.cloudns.ch/post/java1.7-hashmap-implement/"},"publisher":{"@type":"Organization","name":"LYJ's Blog","logo":{"@type":"ImageObject","url":"https://lyj.cloudns.ch/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lyj.cloudns.ch/ accesskey=h title="Home (Alt + H)"><img src=https://lyj.cloudns.ch/home.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lyj.cloudns.ch/ title="LYJ's Blog"><span>首页</span></a></li><li><a href=https://lyj.cloudns.ch/archives/ title=归档><span>归档</span></a></li><li><a href=https://lyj.cloudns.ch/categories/ title=Categories><span>分类</span></a></li><li><a href=https://lyj.cloudns.ch/tags/ title=Tags><span>标签</span></a></li><li><a href=https://lyj.cloudns.ch/search/ title=搜索><span>搜索</span></a></li><li><a href=https://lyj.cloudns.ch/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lyj.cloudns.ch/>主页</a>&nbsp;»&nbsp;<a href=https://lyj.cloudns.ch/post/>Posts</a></div><h1 class="post-title entry-hint-parent">实现HashMap(JDK1.7)</h1><div class=post-description>HashMap是数据结构中的哈希表在Java中的具体实现。JDK1.7的HashMap采用数组+链表的方式实现。</div><div class=post-meta><span title='2023-09-18 20:18:43 +0000 UTC'>2023-09-18</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;3173 字&nbsp;·&nbsp;LYJ</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#哈希表>哈希表</a></li><li><a href=#存储桶数组>存储桶数组</a></li><li><a href=#哈希函数>哈希函数</a><ul><li><a href=#哈希函数构造>哈希函数构造</a></li></ul></li><li><a href=#哈希冲突>哈希冲突</a><ul><li><a href=#解决方法>解决方法</a></li></ul></li><li><a href=#实现hashmap>实现HashMap</a><ul><li><a href=#定义成员变量>定义成员变量</a></li><li><a href=#初始化>初始化</a></li><li><a href=#哈希函数-1>哈希函数</a></li><li><a href=#添加元素>添加元素</a></li><li><a href=#扩容>扩容</a></li><li><a href=#获取元素>获取元素</a></li><li><a href=#删除元素>删除元素</a></li><li><a href=#完整代码>完整代码</a></li><li><a href=#测试>测试</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=哈希表>哈希表<a hidden class=anchor aria-hidden=true href=#哈希表>#</a></h1><p>HashMap是数据结构中的哈希表在Java中的具体实现。
哈希表(Hash Table)是一种常见的数据结构，也被称为散列表。它通过将键映射到存储桶(Buckets)中的位置来高效的存储和检索数据。哈希表使用一个哈希函数来计算键的散列值，然后将散列值映射到存储桶的索引上。
哈希表由<code>存储桶数组</code>和<code>哈希函数</code>组成。</p><h1 id=存储桶数组>存储桶数组<a hidden class=anchor aria-hidden=true href=#存储桶数组>#</a></h1><p>存储桶数组(Bucket Array)是哈希表中用于存储数据的主要结构，它是由一个固定数量的存储桶(Bucket)组成的数组。每个存储桶可以存储一个或多个元素，每个元素都由一个键值对(key-value pair)组成，其中键用于计算哈希值，而值代表实际存储的数据。</p><h1 id=哈希函数>哈希函数<a hidden class=anchor aria-hidden=true href=#哈希函数>#</a></h1><p>哈希函数(Hash Function)是一种算法，它可以将任意长度的输入数据映射成固定长度输出，这个输出通常称为哈希值。</p><h2 id=哈希函数构造>哈希函数构造<a hidden class=anchor aria-hidden=true href=#哈希函数构造>#</a></h2><p>哈希函数的构造是哈希表实现的关键之一。常见的哈希函数构造方法：</p><ol><li>直接定值法：直接通过键值映射到对应的数组位置。</li><li>数字分析法：取键的某些数字作为映射的位置。</li><li>平方取中法：取键平放的中间几位作为映射的位置。</li><li>折叠法：将键分割成数位相同的几段，然后把它们的叠加和作为映射的位置。</li><li>随机数法：使用一个随机数发生器生成一个随机数作为哈希值。</li><li>除留余数法：键除以一个足够大的质数，所得的余数作为哈希地址。</li></ol><h1 id=哈希冲突>哈希冲突<a hidden class=anchor aria-hidden=true href=#哈希冲突>#</a></h1><p>哈希冲突(Hash Collision)是指两个或多个不同的元素被哈希函数映射到相同的哈希值。哈希表设计的目标是将元素均匀的分布在不同的槽位上，以避免冲突和提高效率。然而，由于哈希函数的限制和输入数据的多样性，冲突是难以避免的。</p><h2 id=解决方法>解决方法<a hidden class=anchor aria-hidden=true href=#解决方法>#</a></h2><p>哈希冲突(Hash Collision)解决方法：</p><ol><li>开放地址法：当发生冲突的时候，通过线性探测、二次探测、双重哈希等方法，在哈希表中寻找到下一个可用的位置。</li><li>链地址法：当发生冲突的时候，在哈希表的每一个槽位上维护一个链表，将冲突的元素存储在同一个槽位上。</li><li>再哈希法：构造多个哈希函数，在发生冲突时，更换哈希函数，直到找到空闲位置。</li></ol><h1 id=实现hashmap>实现HashMap<a hidden class=anchor aria-hidden=true href=#实现hashmap>#</a></h1><p>整体设计方案：</p><ul><li>哈希函数：采用<code>hashCode()</code>加上除留余数法</li><li>哈希冲突解决方法：链地址法</li></ul><h2 id=定义成员变量>定义成员变量<a hidden class=anchor aria-hidden=true href=#定义成员变量>#</a></h2><p>定义<code>MyHashMap</code>的成员变量：</p><ol><li>定义默认容量</li><li>定义默认负载因子</li><li>定义MyHashMap的大小</li><li>定义桶数组
自定义内部节点类来实现桶数组</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//自定义内部节点类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 键  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 值  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 后继  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 默认容量  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>DEFAULT_CAPACITY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>16</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 默认负载因子  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>DEFAULT_LOAD_FACTOR</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>75f</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * MyHashMap的大小  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 桶数组  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>buckets</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h2><p>定义两个构造函数，一个为无参构造函数，并为桶设置默认容量；另一个为有参构造函数，通过参数指定桶的容量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 无参构造方法，设置桶数组大小为默认容量  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=nf>MyHashMap</span><span class=p>(){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>buckets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>[</span><span class=n>DEFAULT_CAPACITY</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 有参构造器，设置桶的容量  
</span></span></span><span class=line><span class=cl><span class=cm> * @param capacity int  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=nf>MyHashMap</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>capacity</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>buckets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>[</span><span class=n>capacity</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=哈希函数-1>哈希函数<a hidden class=anchor aria-hidden=true href=#哈希函数-1>#</a></h2><p>通过<code>hashCode()</code>和除留余数法实现哈希函数，来获取哈希地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 哈希函数，获取哈希地址  
</span></span></span><span class=line><span class=cl><span class=cm> * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm> * @return int  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>length</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>abs</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>(</span><span class=n>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=添加元素>添加元素<a hidden class=anchor aria-hidden=true href=#添加元素>#</a></h2><p><strong>添加元素逻辑：</strong></p><ul><li>判断是否需要扩容</li><li>获取元素插入位置</li><li>如果要插入的位置为空，则插入元素</li><li>如果不为空，则遍历链表</li><li>如果元素的key和节点的相同，则覆盖，否则新建节点插入链表头部(JDK7的HashMap使用头插法)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 添加方法  
</span></span></span><span class=line><span class=cl><span class=cm> * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm> * @param value V  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>DEFAULT_LOAD_FACTOR</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>resize</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>putVal</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>buckets</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 将元素存入Node数组  
</span></span></span><span class=line><span class=cl><span class=cm> * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm> * @param value V  
</span></span></span><span class=line><span class=cl><span class=cm> * @param table Node  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>putVal</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>table</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//获取插入位置  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//如果要插入的位置为空，则插入元素  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>size</span><span class=o>++</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//如果不为空，说明发生了哈希冲突，遍历链表使用链地址法  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//如果元素的key和节点的相同，则覆盖  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//新建节点插入链表头部  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>kvNode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>kvNode</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>size</span><span class=o>++</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=扩容>扩容<a hidden class=anchor aria-hidden=true href=#扩容>#</a></h2><p><strong>扩容逻辑：</strong></p><ul><li>创建两倍容量的新数组</li><li>将当前桶中的元素重新哈希到新的数组<ul><li>重新MyHashMap设置大小</li><li>将旧的桶数组的元素移到新的桶数组中</li></ul></li><li>将扩容后的数组赋值给原来的桶数组</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 重新哈希元素  
</span></span></span><span class=line><span class=cl><span class=cm> * @param newNode Node&lt;K,V&gt;[]  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>rehash</span><span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>newNode</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//重新MyHashMap设置大小  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//将旧的桶数组的元素移到新的桶数组中  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>continue</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>//将元素放入新的桶数组  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>putVal</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>,</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>,</span><span class=w> </span><span class=n>newNode</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=获取元素>获取元素<a hidden class=anchor aria-hidden=true href=#获取元素>#</a></h2><p><strong>获取元素逻辑：</strong></p><ul><li>通过哈希获取地址</li><li>如果链表存在遍历链表</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 获取元素  
</span></span></span><span class=line><span class=cl><span class=cm> * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm> * @return V  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=nf>get</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//获取地址  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//如果链表存在遍历链表  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=删除元素>删除元素<a hidden class=anchor aria-hidden=true href=#删除元素>#</a></h2><p><strong>删除元素逻辑：</strong></p><ul><li>如果key存在则删除，不存在直接返回</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 移除元素  
</span></span></span><span class=line><span class=cl><span class=cm> * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>remove</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//获取地址  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w> </span><span class=c1>// 移除成功，结束操作  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w> </span><span class=c1>// 移除成功，结束操作  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w> </span><span class=c1>// 继续遍历链表下一个节点  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=完整代码>完整代码<a hidden class=anchor aria-hidden=true href=#完整代码>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyHashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>         * 键  
</span></span></span><span class=line><span class=cl><span class=cm>         */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>         * 值  
</span></span></span><span class=line><span class=cl><span class=cm>         */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>         * 后继  
</span></span></span><span class=line><span class=cl><span class=cm>         */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 默认容量  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>DEFAULT_CAPACITY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>16</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 默认负载因子  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>DEFAULT_LOAD_FACTOR</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>75f</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * MyHashMap的大小  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 桶数组  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>buckets</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 无参构造方法，设置桶数组大小为默认容量  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>MyHashMap</span><span class=p>(){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>buckets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>[</span><span class=n>DEFAULT_CAPACITY</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 有参构造器，设置桶的容量  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param capacity int  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>MyHashMap</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>capacity</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>buckets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>[</span><span class=n>capacity</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 哈希函数，获取哈希地址  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm>     * @return int  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>length</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>abs</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>(</span><span class=n>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>));</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 添加方法  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param value V  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>DEFAULT_LOAD_FACTOR</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>resize</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>putVal</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>buckets</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 将元素存入Node数组  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param value V  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param table Node  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>putVal</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>table</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//获取插入位置  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>table</span><span class=p>.</span><span class=na>length</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//如果要插入的位置为空，则插入元素  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>size</span><span class=o>++</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//如果不为空，说明发生了哈希冲突，遍历链表使用链地址法  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>//如果元素的key和节点的相同，则覆盖  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=p>;</span><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//新建节点插入链表头部  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>kvNode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>table</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>kvNode</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>size</span><span class=o>++</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 扩容  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>resize</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//创建两倍容量的新数组  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>newNode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>[</span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rehash</span><span class=p>(</span><span class=n>newNode</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>buckets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>newNode</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 重新哈希元素  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param newNode Node&lt;K,V&gt;[]  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>rehash</span><span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>newNode</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//重新MyHashMap设置大小  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//将旧的桶数组的元素移到新的桶数组中  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>continue</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>//将元素放入新的桶数组  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>putVal</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>,</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>,</span><span class=w> </span><span class=n>newNode</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 获取元素  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm>     * @return V  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=nf>get</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//获取地址  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>//如果链表存在遍历链表  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 移除元素  
</span></span></span><span class=line><span class=cl><span class=cm>     * @param key K  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>remove</span><span class=p>(</span><span class=n>K</span><span class=w> </span><span class=n>key</span><span class=p>){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//获取地址  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>buckets</span><span class=p>.</span><span class=na>length</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w> </span><span class=c1>// 移除成功，结束操作  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buckets</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>.</span><span class=na>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=p>;</span><span class=w> </span><span class=c1>// 移除成功，结束操作  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=w> </span><span class=c1>// 继续遍历链表下一个节点  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 返回MyHashMap大小  
</span></span></span><span class=line><span class=cl><span class=cm>     * @return int  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>size</span><span class=p>(){</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Test</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>MyHashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MyHashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;lyj is test&#34;</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>));</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lyj.cloudns.ch/tags/hashmap/>HashMap</a></li></ul><nav class=paginav><a class=prev href=https://lyj.cloudns.ch/post/sychronized-underlying-implementation/><span class=title>« 上一页</span><br><span>sychronized底层实现</span>
</a><a class=next href=https://lyj.cloudns.ch/post/spring-circular-dependency/><span class=title>下一页 »</span><br><span>Spring循环依赖</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lyj.cloudns.ch/>LYJ's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>